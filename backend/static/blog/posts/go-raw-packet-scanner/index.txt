1:"$Sreact.fragment"
2:I[8210,["177","static/chunks/app/layout-d11032fe4cfbd8d7.js"],"PortfolioLink"]
3:I[5244,[],""]
4:I[3866,[],""]
5:I[462,["177","static/chunks/app/layout-d11032fe4cfbd8d7.js"],"UnifiedFooter"]
7:I[6213,[],"OutletBoundary"]
9:I[6213,[],"MetadataBoundary"]
b:I[6213,[],"ViewportBoundary"]
d:I[4835,[],""]
:HL["/blog/_next/static/css/71294b9ceb32b041.css","style"]
0:{"P":null,"b":"z_yVrbsNMle1dgxBK_Vlp","p":"/blog","c":["","posts","go-raw-packet-scanner",""],"i":false,"f":[[["",{"children":["posts",{"children":[["slug","go-raw-packet-scanner","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/blog/_next/static/css/71294b9ceb32b041.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&family=Inter:wght@300;400;500;600&display=swap","rel":"stylesheet"}]}],["$","body",null,{"className":"min-h-screen flex flex-col selection:bg-blue-100 selection:text-blue-900 bg-gray-50 text-black","children":[["$","div",null,{"className":"fixed inset-0 z-[-1] opacity-[0.4]","style":{"backgroundImage":"linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px)","backgroundSize":"40px 40px"}}],["$","div",null,{"className":"fixed top-0 left-0 right-0 h-[500px] bg-gradient-to-b from-blue-50/80 via-white/20 to-transparent pointer-events-none z-[-1]"}],["$","div",null,{"className":"fixed top-[-10%] right-[-5%] w-[500px] h-[500px] bg-blue-100/40 rounded-full blur-3xl pointer-events-none z-[-1]"}],["$","div",null,{"className":"fixed top-[20%] left-[-10%] w-[600px] h-[600px] bg-indigo-50/40 rounded-full blur-3xl pointer-events-none z-[-1]"}],["$","$L2",null,{}],["$","div",null,{"className":"relative z-10 flex-1 w-full text-black","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","$L5",null,{}]]}]]}]]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","go-raw-packet-scanner","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":"$L8"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","Etcv-OjsQKlUFF4uP_ifA",{"children":[["$","$L9",null,{"children":"$La"}],["$","$Lb",null,{"children":"$Lc"}],null]}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
e:I[8328,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],"ReadingProgress"]
f:I[5551,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],"CodeBlockEnhancer"]
10:I[8173,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],""]
11:I[2856,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],"TableOfContents"]
12:I[3704,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],"ReadingFrame"]
14:I[7327,["173","static/chunks/173-faa83631f1926ae1.js","858","static/chunks/app/posts/%5Bslug%5D/page-0bc2d6b42fa0f69f.js"],"ShareButtons"]
13:T288c,<p><em>This is Part 1 of a blog series where I write about the mistakes, crashes, and lessons I learned while building <strong>Revealr</strong>, my own network scanner.</em></p>
<hr>
<p>We all know <code>nmap</code>. You run <code>nmap -sS target</code>, and within seconds, it calmly tells you exactly which ports are open.</p>
<p>For a long time, I had a simple explanation in my head for why it was so fast:
<em>"These tools are fast because they are written in C by geniuses from 30 years ago who understood things I never will."</em></p>
<p>But recently, I started writing more Go. And naturally, this thought came up:
<em>Go is fast. Go has Goroutines. Why can't I just launch 10,000 goroutines and scan ports myself?</em></p>
<p>So I tried. And that’s when I realized something important: <strong>It’s not about the language. It’s about the technique.</strong></p>
<h2 id="the-real-problem-being-too-polite"><a href="#the-real-problem-being-too-polite">The Real Problem: Being Too "Polite"</a></h2>
<p>If you write a normal Go scanner using the standard library function <code>net.Dial("tcp", "target:80")</code>, you are doing things the "official" way. You are asking the Operating System (OS) to make a full connection.</p>
<p>Think of it like calling a friend:</p>
<ol>
<li>You dial the number.</li>
<li>They pick up.</li>
<li>You say "Hello."</li>
<li>They say "Hello."</li>
<li><strong>Then</strong> you hang up.</li>
</ol>
<p>This is the <strong>TCP Three-Way Handshake</strong>.</p>
<p>This is safe, but it is heavy.
If you scan 1,000 ports this way, you are making 1,000 full phone calls. Your computer works hard to track the state of every call, the target server gets annoyed by the logs, and firewalls start blocking you.</p>
<h2 id="the-missed-call-technique-syn-scan"><a href="#the-missed-call-technique-syn-scan">The "Missed Call" Technique (SYN Scan)</a></h2>
<p>Professional scanners don’t make full calls. They give a <strong>Missed Call</strong>.</p>
<ol>
<li><strong>Send SYN</strong> (The Ring).</li>
<li><strong>Receive SYN-ACK</strong> (The phone was picked up).</li>
<li><strong>Send RST</strong> (Cut the call immediately).</li>
</ol>
<p>You never say hello. You never start a conversation. You just confirm that someone picked up.</p>
<p>That’s what a <strong>SYN Scan</strong> is.</p>
<ul>
<li><strong>Fast:</strong> No waiting for handshakes.</li>
<li><strong>Stealthy:</strong> Less likely to clutter application logs.</li>
<li><strong>Efficient:</strong> Your OS doesn't need to allocate memory for a full socket.</li>
</ul>
<p>But here is the catch: <strong>You cannot do this with <code>net.Dial</code>.</strong> The standard library forces you to be polite. To send a "Missed Call," you have to craft the packets yourself—byte by byte.</p>
<h2 id="the-oh-no-phase-crafting-packets-by-hand"><a href="#the-oh-no-phase-crafting-packets-by-hand">The "Oh No" Phase: Crafting Packets by Hand</a></h2>
<p>At first, I genuinely thought: <em>"It’s just data bytes. How hard can it be?"</em></p>
<p>It turns out, very hard.</p>
<p>When you use <strong>Raw Sockets</strong>, the OS stops helping you. You are responsible for building the Ethernet header, the IP header, and the TCP header manually.</p>
<ul>
<li>One wrong bit? The packet is dropped.</li>
<li>No error message.</li>
<li>No warning.</li>
<li>Just silence.</li>
</ul>
<p><strong>The Checksum Bug That Cost Me Hours</strong>
I spent 6 hours one night debugging a scanner that worked perfectly on <code>localhost</code> but failed completely on my LAN. Wireshark showed packets leaving my laptop, but no replies ever came back.</p>
<p>The issue? <strong>The TCP Checksum.</strong></p>
<p>TCP checksums are calculated using a "Pseudo-Header"—a fake header that includes the Source IP and Destination IP. I had forgotten to include this step. The routers on the network looked at my packet, did the math, saw it didn't match, and silently threw my packets in the trash.</p>
<p>Here’s what the packet construction actually looks like using the <code>gopacket</code> library. Notice the comment I added to save my future self:</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// Constructing the TCP Layer</span>
tcpLayer := &#x26;layers.TCP{
    SrcPort: layers.TCPPort(srcPort),
    DstPort: layers.TCPPort(dstPort),
    Seq:     <span class="hljs-number">1105024978</span>, <span class="hljs-comment">// Random sequence number</span>
    SYN:     <span class="hljs-literal">true</span>,       <span class="hljs-comment">// The "Missed Call" flag</span>
    Window:  <span class="hljs-number">14600</span>,      <span class="hljs-comment">// Window size</span>
}

<span class="hljs-comment">// CRITICAL: You must tell the TCP layer about the IP layer.</span>
<span class="hljs-comment">// Without this, the checksum calculation WILL be wrong.</span>
tcpLayer.SetNetworkLayerForChecksum(ipLayer)

<span class="hljs-comment">// Serialize the layers into bytes</span>
buf := gopacket.NewSerializeBuffer()
opts := gopacket.SerializeOptions{
    FixLengths:       <span class="hljs-literal">true</span>, 
    ComputeChecksums: <span class="hljs-literal">true</span>,
}
err := gopacket.SerializeLayers(buf, opts, ethLayer, ipLayer, tcpLayer)

</code></pre>
<h2 id="when-your-own-os-becomes-the-enemy"><a href="#when-your-own-os-becomes-the-enemy">When Your Own OS Becomes the Enemy</a></h2>
<p>This was the most confusing bug I faced—and honestly, one of the most educational.</p>
<p>I finally got the SYN packet crafting right.</p>
<ul>
<li>Packets were going out.</li>
<li>Servers were replying with SYN-ACK.</li>
<li>Everything looked perfect in Wireshark.</li>
</ul>
<p>And yet… my scanner showed <strong>nothing</strong>. No open ports. Just silence.</p>
<p><strong>What Was Actually Happening?</strong>
I was running the scanner on my own laptop. When a server replied with a SYN-ACK, my <strong>Operating System kernel</strong> saw that packet too, not just my program.</p>
<p>The OS Kernel thought:
<em>"Wait, I don't remember starting a TCP connection to this server. Why is it replying to me?"</em></p>
<p>From the Kernel’s point of view, this looked suspicious. So it did what it is designed to do. It immediately sent a <strong>RST (Reset)</strong> packet back to the server.</p>
<p>Basically, my OS was telling the server: <em>"Ignore this. I didn't ask for it."</em></p>
<p>By the time my scanner tried to read the response, the connection was already dead. My own system was sabotaging me—not out of malice, but out of correctness.</p>
<p><strong>The Fix: The Dummy Listener</strong>
To fix this, you have to convince the OS to stop panicking. There are a few ways to do this (like complex <code>iptables</code> firewall rules), but the approach I used early on was a <strong>Dummy Listener</strong>.</p>
<p>The idea is simple:</p>
<ol>
<li>Open a standard local socket on the <em>exact same source port</em> you are using for scanning.</li>
<li>Don't send any data through it. Just let it sit there.</li>
<li>Now, when the SYN-ACK comes back, the Kernel sees the open socket and thinks:
<em>"Ah, I see an owner for this port. This traffic is expected."</em></li>
</ol>
<p>Once the Kernel sees a listener bound to that port, it stops sending the automatic RST packets. Your raw packet code finally gets the response without interference.</p>
<p><em>(I’m intentionally not dumping the full implementation here because it involves some tricky edge cases with port reuse, and there are cleaner ways to do it depending on if you are on Linux or Windows. I will break this down properly in the next blog).</em></p>
<h2 id="the-correlation-problem-matching-replies"><a href="#the-correlation-problem-matching-replies">The Correlation Problem (Matching Replies)</a></h2>
<p>Another thing that confused me early on: Once you send 5,000 packets into the void, the replies come back in random order. Packets don't come back with a sticky note saying <em>"Replying to scan job #42."</em></p>
<p>You need a way to match the answer to the question.</p>
<p>I used a simple <strong>Correlation Map</strong>. I created a unique key for every probe I sent out.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// Key format: "TargetIP:TargetPort:MyPort"</span>
key := fmt.Sprintf(<span class="hljs-string">"TCP:%s:%d:%d"</span>, srcIP, remotePort, localPort)

<span class="hljs-comment">// Store the channel so we know where to send the reply</span>
ps.correlationMap.Store(key, responseChan)

</code></pre>
<p>When a packet arrives, I check the map. If the key exists, I pass the packet to the waiting goroutine. If not, I ignore it. It’s not fancy, but it is reliable under load.</p>
<h2 id="major-takeaways"><a href="#major-takeaways">Major Takeaways</a></h2>
<p>If you are planning to try this, keep these hard-earned lessons in mind:</p>
<ol>
<li><strong>You Need Root/Admin:</strong> You cannot send raw packets without <code>sudo</code> (Linux) or Administrator (Windows). The OS doesn't trust normal users with this power.</li>
<li><strong>MAC Addresses Matter:</strong> If you are scanning outside your local network (like on the internet), your Destination MAC is <strong>your Gateway's MAC</strong>, not the target server's MAC. I wasted a full day figuring this out.</li>
<li><strong>Rate Limit Aggressively:</strong> Home routers are fragile creatures. If you flood them with 10,000 packets at once, they will just crash. Use a semaphore or a token bucket to limit your speed.</li>
</ol>
<h2 id="final-thoughts"><a href="#final-thoughts">Final Thoughts</a></h2>
<p>High-level networking feels clean and simple. Raw networking is not.
It is messy. It is unforgiving. And you are fighting two battles: one against the network, and one against your own Operating System.</p>
<p>But once you understand raw packets, the network stack stops feeling like magic—and starts feeling like exposed wiring. And when your code correctly identifies its first open port from a raw SYN-ACK?</p>
<p>That feeling stays.</p>
<p><strong>Coming Next in Part 2:</strong>
I’ll go deeper into <strong>UDP Scanning</strong>—where silence means everything, and debugging feels like shouting into a dark cave and waiting for an echo. (And I'll show you the full code for managing that Dummy Listener).</p>6:["$","div",null,{"className":"min-h-screen","children":[["$","$Le",null,{}],["$","$Lf",null,{}],["$","nav",null,{"className":"glass-header fixed top-0 left-0 right-0 z-40 px-6 py-4 flex justify-between items-center","children":[["$","div",null,{"className":"font-mono text-xs md:text-sm text-gray-500 flex items-center gap-2","children":[["$","$L10",null,{"href":"/","className":"hover:text-cyan transition-colors","children":"ROOT"}],["$","span",null,{"children":"/"}],["$","$L10",null,{"href":"/","className":"hover:text-cyan transition-colors","children":"ARCHIVES"}],["$","span",null,{"children":"/"}],["$","span",null,{"className":"text-cyan uppercase","children":["OP-","go-raw-p"]}]]}],["$","div",null,{"className":"font-mono text-[10px] text-green-500 border border-green-500/30 px-2 py-1 rounded bg-green-500/10","children":"CLEARANCE: PUBLIC"}]]}],["$","main",null,{"className":"pt-40 pb-32 px-6 md:px-12 max-w-[90rem] mx-auto flex flex-col md:flex-row gap-16 relative","children":[["$","aside",null,{"className":"hidden md:block w-80 sticky top-40 h-fit shrink-0","children":["$","$L11",null,{}]}],["$","article",null,{"className":"flex-1 max-w-5xl prose-custom relative","children":[["$","$L12",null,{"children":[["$","header",null,{"className":"mb-16 border-b border-gray-200 pb-12","children":[["$","div",null,{"className":"flex flex-wrap gap-4 mb-8","children":[["$","span","GO",{"className":"px-3 py-1.5 bg-blue-50 border border-blue-200 text-blue-700 text-xs font-mono tracking-wider rounded uppercase","children":["#","GO"]}],["$","span","NETWORKING",{"className":"px-3 py-1.5 bg-blue-50 border border-blue-200 text-blue-700 text-xs font-mono tracking-wider rounded uppercase","children":["#","NETWORKING"]}],["$","span","SECURITY",{"className":"px-3 py-1.5 bg-blue-50 border border-blue-200 text-blue-700 text-xs font-mono tracking-wider rounded uppercase","children":["#","SECURITY"]}],["$","span","ENGINEERING",{"className":"px-3 py-1.5 bg-blue-50 border border-blue-200 text-blue-700 text-xs font-mono tracking-wider rounded uppercase","children":["#","ENGINEERING"]}]]}],["$","h1",null,{"className":"text-5xl md:text-7xl font-bold font-mono text-black mb-8 leading-tight","children":"What I Learned Building a Go-Powered Raw Packet Scanner (Part 1)"}],["$","div",null,{"className":"flex items-center gap-8 font-mono text-sm text-gray-500","children":[["$","div",null,{"className":"flex items-center gap-2","children":[["$","div",null,{"className":"w-2 h-2 bg-green-500 rounded-full animate-pulse"}],["$","span",null,{"className":"text-gray-500","children":"AUTHOR:"}],["$","a",null,{"href":"https://rounakneema.vercel.app","target":"_blank","rel":"noopener noreferrer","className":"text-blue-600 hover:underline hover:text-blue-800 transition-colors","children":"ROUNAK"}]]}],["$","span",null,{"children":"//"}],["$","span",null,{"children":["DATE: ","2026-01-02"]}],["$","span",null,{"children":"//"}],["$","span",null,{"children":["READ_TIME: ","7 min read"]}]]}]]}],["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$13"}}],["$","div",null,{"id":"share","className":"mt-16 pt-8 border-t border-gray-200","children":["$","$L14",null,{"title":"What I Learned Building a Go-Powered Raw Packet Scanner (Part 1)","slug":"go-raw-packet-scanner"}]}],["$","div",null,{"className":"mt-8 flex items-center justify-between","children":[["$","div",null,{"className":"font-mono text-xs text-gray-500","children":["END OF TRANSMISSION",["$","span",null,{"className":"blink","children":"_"}]]}],["$","$L10",null,{"href":"/","className":"text-cyan font-mono text-xs hover:underline uppercase","children":"[ Return to Archive ]"}]]}]]}],null]}]]}]]}]
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"What I Learned Building a Go-Powered Raw Packet Scanner (Part 1)"}],["$","meta","2",{"name":"description","content":"Part 1 of the Revealr series. Raw packet crafting in Go is messy and unforgiving. Learn how to bypass net.Dial, handle OS interference, and build a SYN scanner from scratch."}],["$","link","3",{"rel":"author","href":"https://rounakneema.vercel.app"}],["$","meta","4",{"name":"author","content":"Rounak Neema"}],["$","meta","5",{"name":"keywords","content":"Cybersecurity,DevOps,Engineering,Go,Security Research,CTF"}],["$","meta","6",{"property":"og:title","content":"Engineering Logs // Rounak"}],["$","meta","7",{"property":"og:description","content":"A personal collection of engineering logs, security research, and learnings."}],["$","meta","8",{"property":"og:url","content":"https://rounakneema.vercel.app/"}],["$","meta","9",{"property":"og:site_name","content":"Engineering Logs"}],["$","meta","10",{"property":"og:locale","content":"en_US"}],["$","meta","11",{"property":"og:type","content":"website"}],["$","meta","12",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","13",{"name":"twitter:creator","content":"@rounakneema"}],["$","meta","14",{"name":"twitter:title","content":"Engineering Logs // Rounak"}],["$","meta","15",{"name":"twitter:description","content":"Security Research & Engineering Logs"}],["$","link","16",{"rel":"icon","href":"/blog/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
8:null
